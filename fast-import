#!/usr/bin/env bash

# CLI
show_help() {
  echo "Usage $0 -F DUMP_FILE [-d DATABASE_NAME] [-a ASYNC_TABLE_NAMES] [-r REPLACE_FROM] [-t REPLACE_TO]"
  echo "Example: $0 -F backup.sql.gz -d booking -a \"table_name|table2_name\" -f incorrect -t correct"
  echo "or simple run to use with default options"
  echo "bash -F backup.sql.gz"
  exit 1
}

start=`date`
dump_file=''
db_name=''
async_imports=''
replace_from=''
replace_to=''
FORCED_INSTALL=false

while getopts "F:d:a:r:t:f" opt; do
    case $opt in
        h)
            show_help
            exit 0
            ;;
        F)  dump_file=$OPTARG
            ;;
        d)  db_name=$OPTARG
            ;;
        a)  async_imports=$OPTARG
            ;;
        r)  replace_from=$OPTARG
            ;;
        t)  replace_to=$OPTARG
            ;;
        f) FORCED_INSTALL=true
            ;;
        \? ) echo "Invalid option: $OPTARG" 1>&2
            show_help >&2
            ;;
    esac
done

shift $((OPTIND -1))

if [[ "$FORCED_INSTALL" = false ]]; then
  exec 3<>/dev/tty
  read -u 3 -p "Этот скрипт уничтожит данные в базе keitaro, вы уверены что хотите продолжить (yes|no)" yn
  case $yn in
      [Yy]*) ;;
      [Nn]*) exit
             ;;
      * )    echo "Please answer yes or no."
             exit
             ;;
  esac
fi

mysql_command=$(mysql --execute='SELECT * FROM INFORMATION_SCHEMA.PROCESSLIST WHERE COMMAND = "Query" AND DB = "keitaro"';)

if [[ $mysql_command ]]; then
    echo "База Keitaro уже используется другим процессом"
    exit 1
fi

if [[ -z "${dump_file}" ]]; then
    echo "-d is required"
    show_help
fi

if test ! -f "$dump_file"; then
    echo "keitaro dump does not exists"
    exit 1
fi

if [[ -z "${db_name}" ]]; then
    db_name='keitaro'
fi

if [[ -z "$async_imports" ]]; then
  async_imports="_clicks|_ref_|visitors"
fi

# prepare directory
rm -rf dump/
mkdir -p dump/

# optimizations
prepend="SET GLOBAL max_connections = 200;"
prepend="$prepend SET UNIQUE_CHECKS = 0; "
prepend="$prepend SET AUTOCOMMIT = 0; "
echo $prepend > dump/prepend.sql

append="SET UNIQUE_CHECKS = 1; "
append="$append SET AUTOCOMMIT = 1; "
append="$append COMMIT ; "
echo $append > dump/append.sql

cd dump/

# unpack
if gzip -dc ../${dump_file} | csplit -s -ftable - "/-- Table structure for table/" {*}; then
  echo 'Success split dump tables'
else
  echo -e '\e[31mDump tables split failed\e[0m'
  exit 1
fi

replaceInFile() {
  if [[ ! -z "${replace_from}" ]] &&  [[ $replace_from != $replace_to ]]; then
    sed -i "s/$replace_from/$replace_to/" $1
  fi
}

# make complite micro dumps
mv table00 head
for file in `ls -1 table*`; do
  table_name=`head -n1 $file | cut -d$'\x60' -f2`
  cat head prepend.sql $file append.sql > "$table_name.sql"
  replaceInFile "$table_name.sql"
done

# cleaning
rm prepend.sql append.sql head table*

# clean db
mysql -e "DROP DATABASE $db_name; CREATE DATABASE $db_name"

# importing
mysql_import(){
  mysql $2 < $1
}

for file in *; do
    mysql_import "$file" "$db_name" &

    table_name=${file%".sql"}
    if [[ ! "$table_name" =~ $async_imports ]]; then
      pids+=($!)
    fi
done

wait "${pids[@]}"

# store end date to a variable
end=`date`

rm -rf ../dump ../${dump_file}

echo "Some parts of the dump will be imported in background. "
